{"ast":null,"code":"import { createExtendedExponentialRampToValueAutomationEvent } from '../functions/create-extended-exponential-ramp-to-value-automation-event';\nimport { createExtendedLinearRampToValueAutomationEvent } from '../functions/create-extended-linear-ramp-to-value-automation-event';\nimport { createSetValueAutomationEvent } from '../functions/create-set-value-automation-event';\nimport { createSetValueCurveAutomationEvent } from '../functions/create-set-value-curve-automation-event';\nimport { getEndTimeAndValueOfPreviousAutomationEvent } from '../functions/get-end-time-and-value-of-previous-automation-event';\nimport { getEventTime } from '../functions/get-event-time';\nimport { getExponentialRampValueAtTime } from '../functions/get-exponential-ramp-value-at-time';\nimport { getLinearRampValueAtTime } from '../functions/get-linear-ramp-value-at-time';\nimport { getTargetValueAtTime } from '../functions/get-target-value-at-time';\nimport { getValueCurveValueAtTime } from '../functions/get-value-curve-value-at-time';\nimport { getValueOfAutomationEventAtIndexAtTime } from '../functions/get-value-of-automation-event-at-index-at-time';\nimport { isAnyRampToValueAutomationEvent } from '../guards/any-ramp-to-value-automation-event';\nimport { isCancelAndHoldAutomationEvent } from '../guards/cancel-and-hold-automation-event';\nimport { isCancelScheduledValuesAutomationEvent } from '../guards/cancel-scheduled-values-automation-event';\nimport { isExponentialRampToValueAutomationEvent } from '../guards/exponential-ramp-to-value-automation-event';\nimport { isLinearRampToValueAutomationEvent } from '../guards/linear-ramp-to-value-automation-event';\nimport { isSetTargetAutomationEvent } from '../guards/set-target-automation-event';\nimport { isSetValueAutomationEvent } from '../guards/set-value-automation-event';\nimport { isSetValueCurveAutomationEvent } from '../guards/set-value-curve-automation-event';\nexport class AutomationEventList {\n  constructor(defaultValue) {\n    this._automationEvents = [];\n    this._currenTime = 0;\n    this._defaultValue = defaultValue;\n  }\n  [Symbol.iterator]() {\n    return this._automationEvents[Symbol.iterator]();\n  }\n  add(automationEvent) {\n    const eventTime = getEventTime(automationEvent);\n    if (isCancelAndHoldAutomationEvent(automationEvent) || isCancelScheduledValuesAutomationEvent(automationEvent)) {\n      const index = this._automationEvents.findIndex(currentAutomationEvent => {\n        if (isCancelScheduledValuesAutomationEvent(automationEvent) && isSetValueCurveAutomationEvent(currentAutomationEvent)) {\n          return currentAutomationEvent.startTime + currentAutomationEvent.duration >= eventTime;\n        }\n        return getEventTime(currentAutomationEvent) >= eventTime;\n      });\n      const removedAutomationEvent = this._automationEvents[index];\n      if (index !== -1) {\n        this._automationEvents = this._automationEvents.slice(0, index);\n      }\n      if (isCancelAndHoldAutomationEvent(automationEvent)) {\n        const lastAutomationEvent = this._automationEvents[this._automationEvents.length - 1];\n        if (removedAutomationEvent !== undefined && isAnyRampToValueAutomationEvent(removedAutomationEvent)) {\n          if (lastAutomationEvent !== undefined && isSetTargetAutomationEvent(lastAutomationEvent)) {\n            throw new Error('The internal list is malformed.');\n          }\n          const startTime = lastAutomationEvent === undefined ? removedAutomationEvent.insertTime : isSetValueCurveAutomationEvent(lastAutomationEvent) ? lastAutomationEvent.startTime + lastAutomationEvent.duration : getEventTime(lastAutomationEvent);\n          const startValue = lastAutomationEvent === undefined ? this._defaultValue : isSetValueCurveAutomationEvent(lastAutomationEvent) ? lastAutomationEvent.values[lastAutomationEvent.values.length - 1] : lastAutomationEvent.value;\n          const value = isExponentialRampToValueAutomationEvent(removedAutomationEvent) ? getExponentialRampValueAtTime(eventTime, startTime, startValue, removedAutomationEvent) : getLinearRampValueAtTime(eventTime, startTime, startValue, removedAutomationEvent);\n          const truncatedAutomationEvent = isExponentialRampToValueAutomationEvent(removedAutomationEvent) ? createExtendedExponentialRampToValueAutomationEvent(value, eventTime, this._currenTime) : createExtendedLinearRampToValueAutomationEvent(value, eventTime, this._currenTime);\n          this._automationEvents.push(truncatedAutomationEvent);\n        }\n        if (lastAutomationEvent !== undefined && isSetTargetAutomationEvent(lastAutomationEvent)) {\n          this._automationEvents.push(createSetValueAutomationEvent(this.getValue(eventTime), eventTime));\n        }\n        if (lastAutomationEvent !== undefined && isSetValueCurveAutomationEvent(lastAutomationEvent) && lastAutomationEvent.startTime + lastAutomationEvent.duration > eventTime) {\n          const duration = eventTime - lastAutomationEvent.startTime;\n          const ratio = (lastAutomationEvent.values.length - 1) / lastAutomationEvent.duration;\n          const length = Math.max(2, 1 + Math.ceil(duration * ratio));\n          const fraction = duration / (length - 1) * ratio;\n          const values = lastAutomationEvent.values.slice(0, length);\n          if (fraction < 1) {\n            for (let i = 1; i < length; i += 1) {\n              const factor = fraction * i % 1;\n              values[i] = lastAutomationEvent.values[i - 1] * (1 - factor) + lastAutomationEvent.values[i] * factor;\n            }\n          }\n          this._automationEvents[this._automationEvents.length - 1] = createSetValueCurveAutomationEvent(values, lastAutomationEvent.startTime, duration);\n        }\n      }\n    } else {\n      const index = this._automationEvents.findIndex(currentAutomationEvent => getEventTime(currentAutomationEvent) > eventTime);\n      const previousAutomationEvent = index === -1 ? this._automationEvents[this._automationEvents.length - 1] : this._automationEvents[index - 1];\n      if (previousAutomationEvent !== undefined && isSetValueCurveAutomationEvent(previousAutomationEvent) && getEventTime(previousAutomationEvent) + previousAutomationEvent.duration > eventTime) {\n        return false;\n      }\n      const persistentAutomationEvent = isExponentialRampToValueAutomationEvent(automationEvent) ? createExtendedExponentialRampToValueAutomationEvent(automationEvent.value, automationEvent.endTime, this._currenTime) : isLinearRampToValueAutomationEvent(automationEvent) ? createExtendedLinearRampToValueAutomationEvent(automationEvent.value, eventTime, this._currenTime) : automationEvent;\n      if (index === -1) {\n        this._automationEvents.push(persistentAutomationEvent);\n      } else {\n        if (isSetValueCurveAutomationEvent(automationEvent) && eventTime + automationEvent.duration > getEventTime(this._automationEvents[index])) {\n          return false;\n        }\n        this._automationEvents.splice(index, 0, persistentAutomationEvent);\n      }\n    }\n    return true;\n  }\n  flush(time) {\n    const index = this._automationEvents.findIndex(currentAutomationEvent => getEventTime(currentAutomationEvent) > time);\n    if (index > 1) {\n      const remainingAutomationEvents = this._automationEvents.slice(index - 1);\n      const firstRemainingAutomationEvent = remainingAutomationEvents[0];\n      if (isSetTargetAutomationEvent(firstRemainingAutomationEvent)) {\n        remainingAutomationEvents.unshift(createSetValueAutomationEvent(getValueOfAutomationEventAtIndexAtTime(this._automationEvents, index - 2, firstRemainingAutomationEvent.startTime, this._defaultValue), firstRemainingAutomationEvent.startTime));\n      }\n      this._automationEvents = remainingAutomationEvents;\n    }\n  }\n  getValue(time) {\n    if (this._automationEvents.length === 0) {\n      return this._defaultValue;\n    }\n    const indexOfNextEvent = this._automationEvents.findIndex(automationEvent => getEventTime(automationEvent) > time);\n    const nextAutomationEvent = this._automationEvents[indexOfNextEvent];\n    const indexOfCurrentEvent = (indexOfNextEvent === -1 ? this._automationEvents.length : indexOfNextEvent) - 1;\n    const currentAutomationEvent = this._automationEvents[indexOfCurrentEvent];\n    if (currentAutomationEvent !== undefined && isSetTargetAutomationEvent(currentAutomationEvent) && (nextAutomationEvent === undefined || !isAnyRampToValueAutomationEvent(nextAutomationEvent) || nextAutomationEvent.insertTime > time)) {\n      return getTargetValueAtTime(time, getValueOfAutomationEventAtIndexAtTime(this._automationEvents, indexOfCurrentEvent - 1, currentAutomationEvent.startTime, this._defaultValue), currentAutomationEvent);\n    }\n    if (currentAutomationEvent !== undefined && isSetValueAutomationEvent(currentAutomationEvent) && (nextAutomationEvent === undefined || !isAnyRampToValueAutomationEvent(nextAutomationEvent))) {\n      return currentAutomationEvent.value;\n    }\n    if (currentAutomationEvent !== undefined && isSetValueCurveAutomationEvent(currentAutomationEvent) && (nextAutomationEvent === undefined || !isAnyRampToValueAutomationEvent(nextAutomationEvent) || currentAutomationEvent.startTime + currentAutomationEvent.duration > time)) {\n      if (time < currentAutomationEvent.startTime + currentAutomationEvent.duration) {\n        return getValueCurveValueAtTime(time, currentAutomationEvent);\n      }\n      return currentAutomationEvent.values[currentAutomationEvent.values.length - 1];\n    }\n    if (currentAutomationEvent !== undefined && isAnyRampToValueAutomationEvent(currentAutomationEvent) && (nextAutomationEvent === undefined || !isAnyRampToValueAutomationEvent(nextAutomationEvent))) {\n      return currentAutomationEvent.value;\n    }\n    if (nextAutomationEvent !== undefined && isExponentialRampToValueAutomationEvent(nextAutomationEvent)) {\n      const [startTime, value] = getEndTimeAndValueOfPreviousAutomationEvent(this._automationEvents, indexOfCurrentEvent, currentAutomationEvent, nextAutomationEvent, this._defaultValue);\n      return getExponentialRampValueAtTime(time, startTime, value, nextAutomationEvent);\n    }\n    if (nextAutomationEvent !== undefined && isLinearRampToValueAutomationEvent(nextAutomationEvent)) {\n      const [startTime, value] = getEndTimeAndValueOfPreviousAutomationEvent(this._automationEvents, indexOfCurrentEvent, currentAutomationEvent, nextAutomationEvent, this._defaultValue);\n      return getLinearRampValueAtTime(time, startTime, value, nextAutomationEvent);\n    }\n    return this._defaultValue;\n  }\n}","map":{"version":3,"names":["createExtendedExponentialRampToValueAutomationEvent","createExtendedLinearRampToValueAutomationEvent","createSetValueAutomationEvent","createSetValueCurveAutomationEvent","getEndTimeAndValueOfPreviousAutomationEvent","getEventTime","getExponentialRampValueAtTime","getLinearRampValueAtTime","getTargetValueAtTime","getValueCurveValueAtTime","getValueOfAutomationEventAtIndexAtTime","isAnyRampToValueAutomationEvent","isCancelAndHoldAutomationEvent","isCancelScheduledValuesAutomationEvent","isExponentialRampToValueAutomationEvent","isLinearRampToValueAutomationEvent","isSetTargetAutomationEvent","isSetValueAutomationEvent","isSetValueCurveAutomationEvent","AutomationEventList","constructor","defaultValue","_automationEvents","_currenTime","_defaultValue","Symbol","iterator","add","automationEvent","eventTime","index","findIndex","currentAutomationEvent","startTime","duration","removedAutomationEvent","slice","lastAutomationEvent","length","undefined","Error","insertTime","startValue","values","value","truncatedAutomationEvent","push","getValue","ratio","Math","max","ceil","fraction","i","factor","previousAutomationEvent","persistentAutomationEvent","endTime","splice","flush","time","remainingAutomationEvents","firstRemainingAutomationEvent","unshift","indexOfNextEvent","nextAutomationEvent","indexOfCurrentEvent"],"sources":["D:\\OneDrive\\Desktop\\testProject\\my-app\\node_modules\\automation-events\\src\\classes\\automation-event-list.ts"],"sourcesContent":["import { createExtendedExponentialRampToValueAutomationEvent } from '../functions/create-extended-exponential-ramp-to-value-automation-event';\nimport { createExtendedLinearRampToValueAutomationEvent } from '../functions/create-extended-linear-ramp-to-value-automation-event';\nimport { createSetValueAutomationEvent } from '../functions/create-set-value-automation-event';\nimport { createSetValueCurveAutomationEvent } from '../functions/create-set-value-curve-automation-event';\nimport { getEndTimeAndValueOfPreviousAutomationEvent } from '../functions/get-end-time-and-value-of-previous-automation-event';\nimport { getEventTime } from '../functions/get-event-time';\nimport { getExponentialRampValueAtTime } from '../functions/get-exponential-ramp-value-at-time';\nimport { getLinearRampValueAtTime } from '../functions/get-linear-ramp-value-at-time';\nimport { getTargetValueAtTime } from '../functions/get-target-value-at-time';\nimport { getValueCurveValueAtTime } from '../functions/get-value-curve-value-at-time';\nimport { getValueOfAutomationEventAtIndexAtTime } from '../functions/get-value-of-automation-event-at-index-at-time';\nimport { isAnyRampToValueAutomationEvent } from '../guards/any-ramp-to-value-automation-event';\nimport { isCancelAndHoldAutomationEvent } from '../guards/cancel-and-hold-automation-event';\nimport { isCancelScheduledValuesAutomationEvent } from '../guards/cancel-scheduled-values-automation-event';\nimport { isExponentialRampToValueAutomationEvent } from '../guards/exponential-ramp-to-value-automation-event';\nimport { isLinearRampToValueAutomationEvent } from '../guards/linear-ramp-to-value-automation-event';\nimport { isSetTargetAutomationEvent } from '../guards/set-target-automation-event';\nimport { isSetValueAutomationEvent } from '../guards/set-value-automation-event';\nimport { isSetValueCurveAutomationEvent } from '../guards/set-value-curve-automation-event';\nimport { TAutomationEvent, TPersistentAutomationEvent } from '../types';\n\nexport class AutomationEventList {\n    private _automationEvents: TPersistentAutomationEvent[];\n\n    private _currenTime: number;\n\n    private _defaultValue: number;\n\n    constructor(defaultValue: number) {\n        this._automationEvents = [];\n        this._currenTime = 0;\n        this._defaultValue = defaultValue;\n    }\n\n    public [Symbol.iterator](): Iterator<TPersistentAutomationEvent> {\n        return this._automationEvents[Symbol.iterator]();\n    }\n\n    public add(automationEvent: TAutomationEvent): boolean {\n        const eventTime = getEventTime(automationEvent);\n\n        if (isCancelAndHoldAutomationEvent(automationEvent) || isCancelScheduledValuesAutomationEvent(automationEvent)) {\n            const index = this._automationEvents.findIndex((currentAutomationEvent) => {\n                if (isCancelScheduledValuesAutomationEvent(automationEvent) && isSetValueCurveAutomationEvent(currentAutomationEvent)) {\n                    return currentAutomationEvent.startTime + currentAutomationEvent.duration >= eventTime;\n                }\n\n                return getEventTime(currentAutomationEvent) >= eventTime;\n            });\n            const removedAutomationEvent = this._automationEvents[index];\n\n            if (index !== -1) {\n                this._automationEvents = this._automationEvents.slice(0, index);\n            }\n\n            if (isCancelAndHoldAutomationEvent(automationEvent)) {\n                const lastAutomationEvent = this._automationEvents[this._automationEvents.length - 1];\n\n                if (removedAutomationEvent !== undefined && isAnyRampToValueAutomationEvent(removedAutomationEvent)) {\n                    if (lastAutomationEvent !== undefined && isSetTargetAutomationEvent(lastAutomationEvent)) {\n                        throw new Error('The internal list is malformed.');\n                    }\n\n                    const startTime =\n                        lastAutomationEvent === undefined\n                            ? removedAutomationEvent.insertTime\n                            : isSetValueCurveAutomationEvent(lastAutomationEvent)\n                            ? lastAutomationEvent.startTime + lastAutomationEvent.duration\n                            : getEventTime(lastAutomationEvent);\n                    const startValue =\n                        lastAutomationEvent === undefined\n                            ? this._defaultValue\n                            : isSetValueCurveAutomationEvent(lastAutomationEvent)\n                            ? lastAutomationEvent.values[lastAutomationEvent.values.length - 1]\n                            : lastAutomationEvent.value;\n                    const value = isExponentialRampToValueAutomationEvent(removedAutomationEvent)\n                        ? getExponentialRampValueAtTime(eventTime, startTime, startValue, removedAutomationEvent)\n                        : getLinearRampValueAtTime(eventTime, startTime, startValue, removedAutomationEvent);\n                    const truncatedAutomationEvent = isExponentialRampToValueAutomationEvent(removedAutomationEvent)\n                        ? createExtendedExponentialRampToValueAutomationEvent(value, eventTime, this._currenTime)\n                        : createExtendedLinearRampToValueAutomationEvent(value, eventTime, this._currenTime);\n\n                    this._automationEvents.push(truncatedAutomationEvent);\n                }\n\n                if (lastAutomationEvent !== undefined && isSetTargetAutomationEvent(lastAutomationEvent)) {\n                    this._automationEvents.push(createSetValueAutomationEvent(this.getValue(eventTime), eventTime));\n                }\n\n                if (\n                    lastAutomationEvent !== undefined &&\n                    isSetValueCurveAutomationEvent(lastAutomationEvent) &&\n                    lastAutomationEvent.startTime + lastAutomationEvent.duration > eventTime\n                ) {\n                    const duration = eventTime - lastAutomationEvent.startTime;\n                    const ratio = (lastAutomationEvent.values.length - 1) / lastAutomationEvent.duration;\n                    const length = Math.max(2, 1 + Math.ceil(duration * ratio));\n                    const fraction = (duration / (length - 1)) * ratio;\n                    const values = lastAutomationEvent.values.slice(0, length);\n\n                    if (fraction < 1) {\n                        for (let i = 1; i < length; i += 1) {\n                            const factor = (fraction * i) % 1;\n\n                            values[i] = lastAutomationEvent.values[i - 1] * (1 - factor) + lastAutomationEvent.values[i] * factor;\n                        }\n                    }\n\n                    this._automationEvents[this._automationEvents.length - 1] = createSetValueCurveAutomationEvent(\n                        values,\n                        lastAutomationEvent.startTime,\n                        duration\n                    );\n                }\n            }\n        } else {\n            const index = this._automationEvents.findIndex((currentAutomationEvent) => getEventTime(currentAutomationEvent) > eventTime);\n\n            const previousAutomationEvent =\n                index === -1 ? this._automationEvents[this._automationEvents.length - 1] : this._automationEvents[index - 1];\n\n            if (\n                previousAutomationEvent !== undefined &&\n                isSetValueCurveAutomationEvent(previousAutomationEvent) &&\n                getEventTime(previousAutomationEvent) + previousAutomationEvent.duration > eventTime\n            ) {\n                return false;\n            }\n\n            const persistentAutomationEvent = isExponentialRampToValueAutomationEvent(automationEvent)\n                ? createExtendedExponentialRampToValueAutomationEvent(automationEvent.value, automationEvent.endTime, this._currenTime)\n                : isLinearRampToValueAutomationEvent(automationEvent)\n                ? createExtendedLinearRampToValueAutomationEvent(automationEvent.value, eventTime, this._currenTime)\n                : automationEvent;\n\n            if (index === -1) {\n                this._automationEvents.push(persistentAutomationEvent);\n            } else {\n                if (\n                    isSetValueCurveAutomationEvent(automationEvent) &&\n                    eventTime + automationEvent.duration > getEventTime(this._automationEvents[index])\n                ) {\n                    return false;\n                }\n\n                this._automationEvents.splice(index, 0, persistentAutomationEvent);\n            }\n        }\n\n        return true;\n    }\n\n    public flush(time: number): void {\n        const index = this._automationEvents.findIndex((currentAutomationEvent) => getEventTime(currentAutomationEvent) > time);\n\n        if (index > 1) {\n            const remainingAutomationEvents = this._automationEvents.slice(index - 1);\n            const firstRemainingAutomationEvent = remainingAutomationEvents[0];\n\n            if (isSetTargetAutomationEvent(firstRemainingAutomationEvent)) {\n                remainingAutomationEvents.unshift(\n                    createSetValueAutomationEvent(\n                        getValueOfAutomationEventAtIndexAtTime(\n                            this._automationEvents,\n                            index - 2,\n                            firstRemainingAutomationEvent.startTime,\n                            this._defaultValue\n                        ),\n                        firstRemainingAutomationEvent.startTime\n                    )\n                );\n            }\n\n            this._automationEvents = remainingAutomationEvents;\n        }\n    }\n\n    public getValue(time: number): number {\n        if (this._automationEvents.length === 0) {\n            return this._defaultValue;\n        }\n\n        const indexOfNextEvent = this._automationEvents.findIndex((automationEvent) => getEventTime(automationEvent) > time);\n        const nextAutomationEvent = this._automationEvents[indexOfNextEvent];\n        const indexOfCurrentEvent = (indexOfNextEvent === -1 ? this._automationEvents.length : indexOfNextEvent) - 1;\n        const currentAutomationEvent = this._automationEvents[indexOfCurrentEvent];\n\n        if (\n            currentAutomationEvent !== undefined &&\n            isSetTargetAutomationEvent(currentAutomationEvent) &&\n            (nextAutomationEvent === undefined ||\n                !isAnyRampToValueAutomationEvent(nextAutomationEvent) ||\n                nextAutomationEvent.insertTime > time)\n        ) {\n            return getTargetValueAtTime(\n                time,\n                getValueOfAutomationEventAtIndexAtTime(\n                    this._automationEvents,\n                    indexOfCurrentEvent - 1,\n                    currentAutomationEvent.startTime,\n                    this._defaultValue\n                ),\n                currentAutomationEvent\n            );\n        }\n\n        if (\n            currentAutomationEvent !== undefined &&\n            isSetValueAutomationEvent(currentAutomationEvent) &&\n            (nextAutomationEvent === undefined || !isAnyRampToValueAutomationEvent(nextAutomationEvent))\n        ) {\n            return currentAutomationEvent.value;\n        }\n\n        if (\n            currentAutomationEvent !== undefined &&\n            isSetValueCurveAutomationEvent(currentAutomationEvent) &&\n            (nextAutomationEvent === undefined ||\n                !isAnyRampToValueAutomationEvent(nextAutomationEvent) ||\n                currentAutomationEvent.startTime + currentAutomationEvent.duration > time)\n        ) {\n            if (time < currentAutomationEvent.startTime + currentAutomationEvent.duration) {\n                return getValueCurveValueAtTime(time, currentAutomationEvent);\n            }\n\n            return currentAutomationEvent.values[currentAutomationEvent.values.length - 1];\n        }\n\n        if (\n            currentAutomationEvent !== undefined &&\n            isAnyRampToValueAutomationEvent(currentAutomationEvent) &&\n            (nextAutomationEvent === undefined || !isAnyRampToValueAutomationEvent(nextAutomationEvent))\n        ) {\n            return currentAutomationEvent.value;\n        }\n\n        if (nextAutomationEvent !== undefined && isExponentialRampToValueAutomationEvent(nextAutomationEvent)) {\n            const [startTime, value] = getEndTimeAndValueOfPreviousAutomationEvent(\n                this._automationEvents,\n                indexOfCurrentEvent,\n                currentAutomationEvent,\n                nextAutomationEvent,\n                this._defaultValue\n            );\n\n            return getExponentialRampValueAtTime(time, startTime, value, nextAutomationEvent);\n        }\n\n        if (nextAutomationEvent !== undefined && isLinearRampToValueAutomationEvent(nextAutomationEvent)) {\n            const [startTime, value] = getEndTimeAndValueOfPreviousAutomationEvent(\n                this._automationEvents,\n                indexOfCurrentEvent,\n                currentAutomationEvent,\n                nextAutomationEvent,\n                this._defaultValue\n            );\n\n            return getLinearRampValueAtTime(time, startTime, value, nextAutomationEvent);\n        }\n\n        return this._defaultValue;\n    }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}