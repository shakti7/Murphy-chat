{"ast":null,"code":"/*\n * The value of the constant Number.MAX_SAFE_INTEGER equals (2 ** 53 - 1) but it\n * is fairly new.\n */\nconst MAX_SAFE_INTEGER = Number.MAX_SAFE_INTEGER === undefined ? 9007199254740991 : Number.MAX_SAFE_INTEGER;\nconst TWO_TO_THE_POWER_OF_TWENTY_NINE = 536870912;\nconst TWO_TO_THE_POWER_OF_THIRTY = TWO_TO_THE_POWER_OF_TWENTY_NINE * 2;\nexport const createGenerateUniqueNumber = (cache, lastNumberWeakMap) => {\n  return collection => {\n    const lastNumber = lastNumberWeakMap.get(collection);\n    /*\n     * Let's try the cheapest algorithm first. It might fail to produce a new\n     * number, but it is so cheap that it is okay to take the risk. Just\n     * increase the last number by one or reset it to 0 if we reached the upper\n     * bound of SMIs (which stands for small integers). When the last number is\n     * unknown it is assumed that the collection contains zero based consecutive\n     * numbers.\n     */\n    let nextNumber = lastNumber === undefined ? collection.size : lastNumber < TWO_TO_THE_POWER_OF_THIRTY ? lastNumber + 1 : 0;\n    if (!collection.has(nextNumber)) {\n      return cache(collection, nextNumber);\n    }\n    /*\n     * If there are less than half of 2 ** 30 numbers stored in the collection,\n     * the chance to generate a new random number in the range from 0 to 2 ** 30\n     * is at least 50%. It's benifitial to use only SMIs because they perform\n     * much better in any environment based on V8.\n     */\n    if (collection.size < TWO_TO_THE_POWER_OF_TWENTY_NINE) {\n      while (collection.has(nextNumber)) {\n        nextNumber = Math.floor(Math.random() * TWO_TO_THE_POWER_OF_THIRTY);\n      }\n      return cache(collection, nextNumber);\n    }\n    // Quickly check if there is a theoretical chance to generate a new number.\n    if (collection.size > MAX_SAFE_INTEGER) {\n      throw new Error('Congratulations, you created a collection of unique numbers which uses all available integers!');\n    }\n    // Otherwise use the full scale of safely usable integers.\n    while (collection.has(nextNumber)) {\n      nextNumber = Math.floor(Math.random() * MAX_SAFE_INTEGER);\n    }\n    return cache(collection, nextNumber);\n  };\n};","map":{"version":3,"names":["MAX_SAFE_INTEGER","Number","undefined","TWO_TO_THE_POWER_OF_TWENTY_NINE","TWO_TO_THE_POWER_OF_THIRTY","createGenerateUniqueNumber","cache","lastNumberWeakMap","collection","lastNumber","get","nextNumber","size","has","Math","floor","random","Error"],"sources":["D:\\OneDrive\\Desktop\\testProject\\my-app\\node_modules\\fast-unique-numbers\\src\\factories\\generate-unique-number.ts"],"sourcesContent":["import { TGenerateUniqueNumberFactory } from '../types';\n\n/*\n * The value of the constant Number.MAX_SAFE_INTEGER equals (2 ** 53 - 1) but it\n * is fairly new.\n */\nconst MAX_SAFE_INTEGER = Number.MAX_SAFE_INTEGER === undefined ? 9007199254740991 : Number.MAX_SAFE_INTEGER;\nconst TWO_TO_THE_POWER_OF_TWENTY_NINE = 536870912;\nconst TWO_TO_THE_POWER_OF_THIRTY = TWO_TO_THE_POWER_OF_TWENTY_NINE * 2;\n\nexport const createGenerateUniqueNumber: TGenerateUniqueNumberFactory = (cache, lastNumberWeakMap) => {\n    return (collection) => {\n        const lastNumber = lastNumberWeakMap.get(collection);\n\n        /*\n         * Let's try the cheapest algorithm first. It might fail to produce a new\n         * number, but it is so cheap that it is okay to take the risk. Just\n         * increase the last number by one or reset it to 0 if we reached the upper\n         * bound of SMIs (which stands for small integers). When the last number is\n         * unknown it is assumed that the collection contains zero based consecutive\n         * numbers.\n         */\n        let nextNumber = lastNumber === undefined ? collection.size : lastNumber < TWO_TO_THE_POWER_OF_THIRTY ? lastNumber + 1 : 0;\n\n        if (!collection.has(nextNumber)) {\n            return cache(collection, nextNumber);\n        }\n\n        /*\n         * If there are less than half of 2 ** 30 numbers stored in the collection,\n         * the chance to generate a new random number in the range from 0 to 2 ** 30\n         * is at least 50%. It's benifitial to use only SMIs because they perform\n         * much better in any environment based on V8.\n         */\n        if (collection.size < TWO_TO_THE_POWER_OF_TWENTY_NINE) {\n            while (collection.has(nextNumber)) {\n                nextNumber = Math.floor(Math.random() * TWO_TO_THE_POWER_OF_THIRTY);\n            }\n\n            return cache(collection, nextNumber);\n        }\n\n        // Quickly check if there is a theoretical chance to generate a new number.\n        if (collection.size > MAX_SAFE_INTEGER) {\n            throw new Error('Congratulations, you created a collection of unique numbers which uses all available integers!');\n        }\n\n        // Otherwise use the full scale of safely usable integers.\n        while (collection.has(nextNumber)) {\n            nextNumber = Math.floor(Math.random() * MAX_SAFE_INTEGER);\n        }\n\n        return cache(collection, nextNumber);\n    };\n};\n"],"mappings":"AAEA;;;;AAIA,MAAMA,gBAAgB,GAAGC,MAAM,CAACD,gBAAgB,KAAKE,SAAS,GAAG,gBAAgB,GAAGD,MAAM,CAACD,gBAAgB;AAC3G,MAAMG,+BAA+B,GAAG,SAAS;AACjD,MAAMC,0BAA0B,GAAGD,+BAA+B,GAAG,CAAC;AAEtE,OAAO,MAAME,0BAA0B,GAAiCA,CAACC,KAAK,EAAEC,iBAAiB,KAAI;EACjG,OAAQC,UAAU,IAAI;IAClB,MAAMC,UAAU,GAAGF,iBAAiB,CAACG,GAAG,CAACF,UAAU,CAAC;IAEpD;;;;;;;;IAQA,IAAIG,UAAU,GAAGF,UAAU,KAAKP,SAAS,GAAGM,UAAU,CAACI,IAAI,GAAGH,UAAU,GAAGL,0BAA0B,GAAGK,UAAU,GAAG,CAAC,GAAG,CAAC;IAE1H,IAAI,CAACD,UAAU,CAACK,GAAG,CAACF,UAAU,CAAC,EAAE;MAC7B,OAAOL,KAAK,CAACE,UAAU,EAAEG,UAAU,CAAC;;IAGxC;;;;;;IAMA,IAAIH,UAAU,CAACI,IAAI,GAAGT,+BAA+B,EAAE;MACnD,OAAOK,UAAU,CAACK,GAAG,CAACF,UAAU,CAAC,EAAE;QAC/BA,UAAU,GAAGG,IAAI,CAACC,KAAK,CAACD,IAAI,CAACE,MAAM,EAAE,GAAGZ,0BAA0B,CAAC;;MAGvE,OAAOE,KAAK,CAACE,UAAU,EAAEG,UAAU,CAAC;;IAGxC;IACA,IAAIH,UAAU,CAACI,IAAI,GAAGZ,gBAAgB,EAAE;MACpC,MAAM,IAAIiB,KAAK,CAAC,gGAAgG,CAAC;;IAGrH;IACA,OAAOT,UAAU,CAACK,GAAG,CAACF,UAAU,CAAC,EAAE;MAC/BA,UAAU,GAAGG,IAAI,CAACC,KAAK,CAACD,IAAI,CAACE,MAAM,EAAE,GAAGhB,gBAAgB,CAAC;;IAG7D,OAAOM,KAAK,CAACE,UAAU,EAAEG,UAAU,CAAC;EACxC,CAAC;AACL,CAAC"},"metadata":{},"sourceType":"module","externalDependencies":[]}